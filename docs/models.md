# モデル

多くのフレームワークでは、モデルというのはデータベースとの ORM で使われる単語ですが、Volt のモデルのコンセプトはそれとは少し異なっています。Volt において、モデルはデータを簡単に保存しておくために利用できるクラスを指します。モデルを作成するときには Persistor (永続化機構) を待たせることができます。その Persistor というものが、モデルのデータを保持しておく役割を果たします。Persistor を使わずに作成したモデルでは、データは単純にクラスのインスタンスに保存されます。どのようにモデルを使うのか、まず見てみましょう。

Volt には多くのモデルが組み込まれており、その1つに `page` モデルがあります。コントローラーで `#page` を呼び出すことでそのモデルにアクセスすることができます。

```ruby
page._name = 'Ryan'
page._name
# => 'Ryan'
```

モデルは、先頭がアンダースコアで始まるゲッター/セッターでアクセスすることのできるハッシュのように振る舞います。もし、そのアトリビュートまだ設定されていないものだった場合には「nil モデル」が返ってきます。アンダースコアを前置することによって、存在しないメソッドを誤って呼び出すことを回避したり、例外が発生することを避けて nil モデルを返すようにすることができます。フィールドはハッシュのように振る舞いますが、アクセスと代入については異なるシンタックスを使用します。

-- # TODO: Add docs on fields in classes

また、モデルは中間的なモデルを作成することなくネストすることができます。

```ruby
page._settings._color = 'blue'
page._settings._color
# => @'blue'

page._settings
# => @#<Model:_settings {:_color=>"blue"}>
```

ネストされたデータは、代入時に自動的に設定されます。上記の例では、page._setting は page モデルの一部を形成するモデルとなります。このことによって、事前に設定を行うことなく、ネストされたモデルをバインディングすることが可能になっています。

Volt のモデルでは、複数形の名前を持ったプロパティは ArrayModel のインスタンスを返します。ArrayModel は通常のアレイと同じように振る舞います。要素の追加/削除は通常のアレイと同様のメソッド (#<<, push, append, delete, delete_at, etc...) で行うことができます。

```ruby
page._items
# #<ArrayModel:70303686333720 []>

page._items << {_name: 'Item 1'}

page._items
# #<ArrayModel:70303686333720 [<Model:70303682055800 {:_name=>"Item 1"}>]>

page._items.size
# => 1

page._items[0]
# => <Model:70303682055800 {:_name=>"Item 1"}>
```
